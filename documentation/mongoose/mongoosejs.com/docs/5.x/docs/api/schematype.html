<!DOCTYPE html><html lang="en">
<!-- Mirrored from mongoosejs.com/docs/5.x/docs/api/schematype.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 18 Apr 2022 10:54:55 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Mongoose v5.13.14: </title><link rel="apple-touch-icon" sizes="57x57" href="images/favicon/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="images/favicon/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="images/favicon/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="images/favicon/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="images/favicon/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="images/favicon/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="images/favicon/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="images/favicon/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="images/favicon/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="images/favicon/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="images/favicon/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="images/favicon/favicon-16x16.png"><link rel="stylesheet" href="../../../../../unpkg.com/purecss%401.0.0/build/pure-min.css" integrity="sha384-nn4HPE8lTHyVtfCBi5yW9d20FjT8BJwUXyWZT9InLYax14RDjBj46LmSztkmNP9w" crossorigin="anonymous"><link rel="stylesheet" href="../../../../../fonts.googleapis.com/cssd2d5.css?family=Open+Sans"><link rel="stylesheet" href="../../../css/github.css"><link rel="stylesheet" href="../../../css/mongoose5.css"><link rel="apple-touch-icon" sizes="57x57" href="images/favicon/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="images/favicon/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="images/favicon/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="images/favicon/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="images/favicon/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="images/favicon/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="images/favicon/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="images/favicon/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="images/favicon/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="images/favicon/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="images/favicon/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="images/favicon/favicon-16x16.png"><link rel="manifest" href="images/favicon/manifest.html"><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="images/favicon/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="stylesheet" href="../../../css/api.css"><link rel="stylesheet" href="../../../css/inlinecpc.css"><script type="text/javascript" src="../../../js/native.js"></script><style>.api-nav .nav-item-sub {
  display: block !important;
}

.api-content {
  margin-top: 3em;
}
</style></head><body><div id="layout"><div id="mobile-menu"><a class="menu-link" id="menuLink" href="#menu"><span></span></a><div id="mobile-logo-container"><a href="../../../../index.html"><img id="logo" src="../../../images/mongoose5_62x30_transparent.png"><span class="logo-text">mongoose</span></a></div></div><div id="menu"><div class="pure-menu"><div class="pure-menu-heading" id="logo-container"><a href="../../../../index.html"><img id="logo" src="../../../images/mongoose5_62x30_transparent.png"><span class="logo-text">mongoose</span></a></div><ul class="pure-menu-list" id="navbar"><li class="pure-menu-horizontal pure-menu-item pure-menu-has-children pure-menu-allow-hover version"><a class="pure-menu-link" href="#">Version 5.13.14</a><ul class="pure-menu-children"><li class="pure-menu-item"><a class="pure-menu-link" href="../../../index-2.html">Version 6.x</a></li><li class="pure-menu-item"><a class="pure-menu-link" href="../../../4.x/index.html">Version 4.13.21</a></li><li class="pure-menu-item"><a class="pure-menu-link" href="../../../3.8.x/index.html">Version 3.8.40</a></li></ul></li><li class="pure-menu-item search"><input id="search-input-nav" type="text" placeholder="Search"><button id="search-button-nav"><img src="../../../images/search.svg"></button></li><li class="pure-menu-item"><a class="pure-menu-link" href="../index.html">Quick Start</a></li><li class="pure-menu-item"><a class="pure-menu-link" href="../guides.html">Guides</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="../guide.html">Schemas</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="../schematypes.html">SchemaTypes</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="../connections.html">Connections</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="../models.html">Models</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="../documents.html">Documents</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="../subdocs.html">Subdocuments</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="../queries.html">Queries</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="../validation.html">Validation</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="../middleware.html">Middleware</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="../populate.html">Populate</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="../discriminators.html">Discriminators</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="../plugins.html">Plugins</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="../transactions.html">Transactions</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="../typescript.html">TypeScript</a></li><li class="pure-menu-item"><a class="pure-menu-link" href="../api.html">API</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="mongoose.html">Mongoose</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="schema.html">Schema</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="connection.html">Connection</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="document.html">Document</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="model.html">Model</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="query.html">Query</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="aggregate.html">Aggregate</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link selected" href="schematype.html">SchemaType</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="virtualtype.html">VirtualType</a></li><li class="pure-menu-item"><a class="pure-menu-link" href="../compatibility.html">Version Compatibility</a></li><li class="pure-menu-item"><a class="pure-menu-link" href="../faq.html">FAQ</a></li><li class="pure-menu-item"><a class="pure-menu-link" href="../further_reading.html">Further Reading</a></li><li class="pure-menu-item"><a class="pure-menu-link" href="../enterprise.html">For Enterprise</a></li><li class="pure-menu-item"><a class="pure-menu-link" href="../built-with-mongoose.html" >Built with Mongoose</a></li></ul><div class="cpc-ad"><script async type="text/javascript" src="../../../../../cdn.carbonads.com/carbonc27f.js?zoneid=1673&amp;serve=C6AILKT&amp;placement=mongoosejscom" id="_carbonads_js"></script></div></div></div><div class="container"><div id="content"><a class="edit-docs-link" href="https://github.com/Automattic/mongoose/blob/master/lib/schematype.js" target="_blank">
<img src="../../../images/pencil.svg" />
</a><h1>Schematype</h1><div><div class="native-inline">
  <a href="#native_link#"><span class="sponsor">Sponsor</span> #native_company# â€” #native_desc#</a>
</div>
</div><div class="api-nav"><div class="api-nav-content"><div class="nav-item" id="nav-Mongoose"><div class="nav-item-title"><a href="mongoose.html">Mongoose</a></div></div><div class="nav-item" id="nav-Schema"><div class="nav-item-title"><a href="schema.html">Schema</a></div></div><div class="nav-item" id="nav-Connection"><div class="nav-item-title"><a href="connection.html">Connection</a></div></div><div class="nav-item" id="nav-Document"><div class="nav-item-title"><a href="document.html">Document</a></div></div><div class="nav-item" id="nav-Model"><div class="nav-item-title"><a href="model.html">Model</a></div></div><div class="nav-item" id="nav-Query"><div class="nav-item-title"><a href="query.html">Query</a></div></div><div class="nav-item" id="nav-QueryCursor"><div class="nav-item-title"><a href="querycursor.html">QueryCursor</a></div></div><div class="nav-item" id="nav-Aggregate"><div class="nav-item-title"><a href="aggregate.html">Aggregate</a></div></div><div class="nav-item" id="nav-AggregationCursor"><div class="nav-item-title"><a href="aggregationcursor.html">AggregationCursor</a></div></div><div class="nav-item" id="nav-Schematype"><div class="nav-item-title" style="font-weight: bold"><a href="schematype.html">Schematype</a></div><ul class="nav-item-sub"><li><a href="#schematype_SchemaType">SchemaType()</a></li><li><a href="#schematype_SchemaType-cast">SchemaType.prototype.cast()</a></li><li><a href="#schematype_SchemaType-default">SchemaType.prototype.default()</a></li><li><a href="#schematype_SchemaType-get">SchemaType.prototype.get()</a></li><li><a href="#schematype_SchemaType-immutable">SchemaType.prototype.immutable()</a></li><li><a href="#schematype_SchemaType-index">SchemaType.prototype.index()</a></li><li><a href="#schematype_SchemaType-ref">SchemaType.prototype.ref()</a></li><li><a href="#schematype_SchemaType-required">SchemaType.prototype.required()</a></li><li><a href="#schematype_SchemaType-select">SchemaType.prototype.select()</a></li><li><a href="#schematype_SchemaType-set">SchemaType.prototype.set()</a></li><li><a href="#schematype_SchemaType-sparse">SchemaType.prototype.sparse()</a></li><li><a href="#schematype_SchemaType-text">SchemaType.prototype.text()</a></li><li><a href="#schematype_SchemaType-transform">SchemaType.prototype.transform()</a></li><li><a href="#schematype_SchemaType-unique">SchemaType.prototype.unique()</a></li><li><a href="#schematype_SchemaType-validate">SchemaType.prototype.validate()</a></li><li><a href="#schematype_SchemaType-cast">Schematype.cast()</a></li><li><a href="#schematype_SchemaType-cast">Schematype.cast()</a></li><li><a href="#schematype_SchemaType-checkRequired">Schematype.checkRequired()</a></li><li><a href="#schematype_SchemaType-get">Schematype.get()</a></li><li><a href="#schematype_SchemaType-set">Schematype.set()</a></li></ul></div><div class="nav-item" id="nav-Virtualtype"><div class="nav-item-title"><a href="virtualtype.html">Virtualtype</a></div></div><div class="nav-item" id="nav-Error"><div class="nav-item-title"><a href="error.html">Error</a></div></div><div class="nav-item" id="nav-Array"><div class="nav-item-title"><a href="array.html">Array</a></div></div><div class="nav-item" id="nav-SchemaArray"><div class="nav-item-title"><a href="schemaarray.html">SchemaArray</a></div></div><div class="nav-item" id="nav-DocumentArrayPath"><div class="nav-item-title"><a href="documentarraypath.html">DocumentArrayPath</a></div></div><div class="nav-item" id="nav-SingleNestedPath"><div class="nav-item-title"><a href="singlenestedpath.html">SingleNestedPath</a></div></div></div></div><div class="api-content"><ul><li><a href="#schematype_SchemaType">SchemaType()</a></li><li><a href="#schematype_SchemaType-cast">SchemaType.prototype.cast()</a></li><li><a href="#schematype_SchemaType-default">SchemaType.prototype.default()</a></li><li><a href="#schematype_SchemaType-get">SchemaType.prototype.get()</a></li><li><a href="#schematype_SchemaType-immutable">SchemaType.prototype.immutable()</a></li><li><a href="#schematype_SchemaType-index">SchemaType.prototype.index()</a></li><li><a href="#schematype_SchemaType-ref">SchemaType.prototype.ref()</a></li><li><a href="#schematype_SchemaType-required">SchemaType.prototype.required()</a></li><li><a href="#schematype_SchemaType-select">SchemaType.prototype.select()</a></li><li><a href="#schematype_SchemaType-set">SchemaType.prototype.set()</a></li><li><a href="#schematype_SchemaType-sparse">SchemaType.prototype.sparse()</a></li><li><a href="#schematype_SchemaType-text">SchemaType.prototype.text()</a></li><li><a href="#schematype_SchemaType-transform">SchemaType.prototype.transform()</a></li><li><a href="#schematype_SchemaType-unique">SchemaType.prototype.unique()</a></li><li><a href="#schematype_SchemaType-validate">SchemaType.prototype.validate()</a></li><li><a href="#schematype_SchemaType-cast">Schematype.cast()</a></li><li><a href="#schematype_SchemaType-cast">Schematype.cast()</a></li><li><a href="#schematype_SchemaType-checkRequired">Schematype.checkRequired()</a></li><li><a href="#schematype_SchemaType-get">Schematype.get()</a></li><li><a href="#schematype_SchemaType-set">Schematype.set()</a></li></ul><hr class="separate-api-elements"><h3 id="schematype_SchemaType"><a href="#schematype_SchemaType">SchemaType()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">path
<span class="method-type">&laquo;String&raquo;</span> </li><li class="param">[options]
<span class="method-type">&laquo;SchemaTypeOptions&raquo;</span> See <a href="../../../api/schematypeoptions.html">SchemaTypeOptions docs</a></p>
</li><li class="param">[instance]
<span class="method-type">&laquo;String&raquo;</span> </li></ul><div><p>SchemaType constructor. Do <strong>not</strong> instantiate <code>SchemaType</code> directly. Mongoose converts your schema paths into SchemaTypes automatically.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">const</span> schema = <span class="hljs-keyword">new</span> Schema({ <span class="hljs-attr">name</span>: <span class="hljs-built_in">String</span> });
schema.path(<span class="hljs-string">'name'</span>) <span class="hljs-keyword">instanceof</span> SchemaType; <span class="hljs-comment">// true</span></code></pre>  </div><hr class="separate-api-elements"><h3 id="schematype_SchemaType-cast"><a href="#schematype_SchemaType-cast">SchemaType.prototype.cast()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">value
<span class="method-type">&laquo;Object&raquo;</span> value to cast</p>
</li><li class="param">doc
<span class="method-type">&laquo;Document&raquo;</span> document that triggers the casting</p>
</li><li class="param">init
<span class="method-type">&laquo;Boolean&raquo;</span> </li></ul><div><p>The function that Mongoose calls to cast arbitrary values to this SchemaType.</p>  </div><hr class="separate-api-elements"><h3 id="schematype_SchemaType-default"><a href="#schematype_SchemaType-default">SchemaType.prototype.default()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">val
<span class="method-type">&laquo;Function|any&raquo;</span> the default value</p>
</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;defaultValue&raquo;</span> </li></ul><div><p>Sets a default value for this SchemaType.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">const</span> schema = <span class="hljs-keyword">new</span> Schema({ <span class="hljs-attr">n</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">Number</span>, <span class="hljs-attr">default</span>: <span class="hljs-number">10</span> })
<span class="hljs-keyword">const</span> M = db.model(<span class="hljs-string">'M'</span>, schema)
<span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> M;
<span class="hljs-built_in">console</span>.log(m.n) <span class="hljs-comment">// 10</span></code></pre>

<p>Defaults can be either <code>functions</code> which return the value to use as the default or the literal value itself. Either way, the value will be cast based on its schema type before being set during document creation.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-comment">// values are cast:</span>
<span class="hljs-keyword">const</span> schema = <span class="hljs-keyword">new</span> Schema({ <span class="hljs-attr">aNumber</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">Number</span>, <span class="hljs-attr">default</span>: <span class="hljs-number">4.815162342</span> }})
<span class="hljs-keyword">const</span> M = db.model(<span class="hljs-string">'M'</span>, schema)
<span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> M;
<span class="hljs-built_in">console</span>.log(m.aNumber) <span class="hljs-comment">// 4.815162342</span>

<span class="hljs-comment">// default unique objects for Mixed types:</span>
<span class="hljs-keyword">const</span> schema = <span class="hljs-keyword">new</span> Schema({ <span class="hljs-attr">mixed</span>: Schema.Types.Mixed });
schema.path(<span class="hljs-string">'mixed'</span>).default(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> {};
});

<span class="hljs-comment">// if we don't use a function to return object literals for Mixed defaults,</span>
<span class="hljs-comment">// each document will receive a reference to the same object literal creating</span>
<span class="hljs-comment">// a "shared" object instance:</span>
<span class="hljs-keyword">const</span> schema = <span class="hljs-keyword">new</span> Schema({ <span class="hljs-attr">mixed</span>: Schema.Types.Mixed });
schema.path(<span class="hljs-string">'mixed'</span>).default({});
<span class="hljs-keyword">const</span> M = db.model(<span class="hljs-string">'M'</span>, schema);
<span class="hljs-keyword">const</span> m1 = <span class="hljs-keyword">new</span> M;
m1.mixed.added = <span class="hljs-number">1</span>;
<span class="hljs-built_in">console</span>.log(m1.mixed); <span class="hljs-comment">// { added: 1 }</span>
<span class="hljs-keyword">const</span> m2 = <span class="hljs-keyword">new</span> M;
<span class="hljs-built_in">console</span>.log(m2.mixed); <span class="hljs-comment">// { added: 1 }</span></code></pre>  </div><hr class="separate-api-elements"><h3 id="schematype_SchemaType-get"><a href="#schematype_SchemaType-get">SchemaType.prototype.get()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">fn
<span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;SchemaType&raquo;</span> this</p>
</li></ul><div><p>Adds a getter to this schematype.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dob</span> (<span class="hljs-params">val</span>) </span>{
  <span class="hljs-keyword">if</span> (!val) <span class="hljs-keyword">return</span> val;
  <span class="hljs-keyword">return</span> (val.getMonth() + <span class="hljs-number">1</span>) + <span class="hljs-string">"/"</span> + val.getDate() + <span class="hljs-string">"/"</span> + val.getFullYear();
}

<span class="hljs-comment">// defining within the schema</span>
<span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> Schema({ <span class="hljs-attr">born</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">Date</span>, <span class="hljs-attr">get</span>: dob })

<span class="hljs-comment">// or by retreiving its SchemaType</span>
<span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> Schema({ <span class="hljs-attr">born</span>: <span class="hljs-built_in">Date</span> })
s.path(<span class="hljs-string">'born'</span>).get(dob)</code></pre>

<p>Getters allow you to transform the representation of the data as it travels from the raw mongodb document to the value that you see.</p>

<p>Suppose you are storing credit card numbers and you want to hide everything except the last 4 digits to the mongoose user. You can do so by defining a getter in the following way:</p>

<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">obfuscate</span> (<span class="hljs-params">cc</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">'****-****-****-'</span> + cc.slice(cc.length<span class="hljs-number">-4</span>, cc.length);
}

<span class="hljs-keyword">const</span> AccountSchema = <span class="hljs-keyword">new</span> Schema({
  <span class="hljs-attr">creditCardNumber</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">get</span>: obfuscate }
});

<span class="hljs-keyword">const</span> Account = db.model(<span class="hljs-string">'Account'</span>, AccountSchema);

Account.findById(id, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, found</span>) </span>{
  <span class="hljs-built_in">console</span>.log(found.creditCardNumber); <span class="hljs-comment">// '****-****-****-1234'</span>
});</code></pre>

<p>Getters are also passed a second argument, the schematype on which the getter was defined. This allows for tailored behavior based on options passed in the schema.</p>

<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inspector</span> (<span class="hljs-params">val, schematype</span>) </span>{
  <span class="hljs-keyword">if</span> (schematype.options.required) {
    <span class="hljs-keyword">return</span> schematype.path + <span class="hljs-string">' is required'</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> schematype.path + <span class="hljs-string">' is not'</span>;
  }
}

<span class="hljs-keyword">const</span> VirusSchema = <span class="hljs-keyword">new</span> Schema({
  <span class="hljs-attr">name</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">get</span>: inspector },
  <span class="hljs-attr">taxonomy</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">get</span>: inspector }
})

<span class="hljs-keyword">const</span> Virus = db.model(<span class="hljs-string">'Virus'</span>, VirusSchema);

Virus.findById(id, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, virus</span>) </span>{
  <span class="hljs-built_in">console</span>.log(virus.name);     <span class="hljs-comment">// name is required</span>
  <span class="hljs-built_in">console</span>.log(virus.taxonomy); <span class="hljs-comment">// taxonomy is not</span>
})</code></pre>  </div><hr class="separate-api-elements"><h3 id="schematype_SchemaType-immutable"><a href="#schematype_SchemaType-immutable">SchemaType.prototype.immutable()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">bool
<span class="method-type">&laquo;Boolean&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;SchemaType&raquo;</span> this</p>
</li></ul><div><p>Defines this path as immutable. Mongoose prevents you from changing immutable paths unless the parent document has <a href="../../../api.html#document_Document-isNew"><code>isNew: true</code></a>.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">const</span> schema = <span class="hljs-keyword">new</span> Schema({
  <span class="hljs-attr">name</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">immutable</span>: <span class="hljs-literal">true</span> },
  <span class="hljs-attr">age</span>: <span class="hljs-built_in">Number</span>
});
<span class="hljs-keyword">const</span> Model = mongoose.model(<span class="hljs-string">'Test'</span>, schema);

<span class="hljs-keyword">await</span> Model.create({ <span class="hljs-attr">name</span>: <span class="hljs-string">'test'</span> });
<span class="hljs-keyword">const</span> doc = <span class="hljs-keyword">await</span> Model.findOne();

doc.isNew; <span class="hljs-comment">// false</span>
doc.name = <span class="hljs-string">'new name'</span>;
doc.name; <span class="hljs-comment">// 'test', because `name` is immutable</span></code></pre>

<p>Mongoose also prevents changing immutable properties using <code>updateOne()</code> and <code>updateMany()</code> based on <a href="../../../guide.html#strict">strict mode</a>.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-comment">// Mongoose will strip out the `name` update, because `name` is immutable</span>
Model.updateOne({}, { <span class="hljs-attr">$set</span>: { <span class="hljs-attr">name</span>: <span class="hljs-string">'test2'</span> }, <span class="hljs-attr">$inc</span>: { <span class="hljs-attr">age</span>: <span class="hljs-number">1</span> } });

<span class="hljs-comment">// If `strict` is set to 'throw', Mongoose will throw an error if you</span>
<span class="hljs-comment">// update `name`</span>
<span class="hljs-keyword">const</span> err = <span class="hljs-keyword">await</span> Model.updateOne({}, { <span class="hljs-attr">name</span>: <span class="hljs-string">'test2'</span> }, { <span class="hljs-attr">strict</span>: <span class="hljs-string">'throw'</span> }).
  then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-literal">null</span>, err =&gt; err);
err.name; <span class="hljs-comment">// StrictModeError</span>

<span class="hljs-comment">// If `strict` is `false`, Mongoose allows updating `name` even though</span>
<span class="hljs-comment">// the property is immutable.</span>
Model.updateOne({}, { <span class="hljs-attr">name</span>: <span class="hljs-string">'test2'</span> }, { <span class="hljs-attr">strict</span>: <span class="hljs-literal">false</span> });</code></pre>  </div><hr class="separate-api-elements"><h3 id="schematype_SchemaType-index"><a href="#schematype_SchemaType-index">SchemaType.prototype.index()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">options
<span class="method-type">&laquo;Object|Boolean|String&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;SchemaType&raquo;</span> this</p>
</li></ul><div><p>Declares the index options for this schematype.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> Schema({ <span class="hljs-attr">name</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">index</span>: <span class="hljs-literal">true</span> })
<span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> Schema({ <span class="hljs-attr">loc</span>: { <span class="hljs-attr">type</span>: [<span class="hljs-built_in">Number</span>], <span class="hljs-attr">index</span>: <span class="hljs-string">'hashed'</span> })
<span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> Schema({ <span class="hljs-attr">loc</span>: { <span class="hljs-attr">type</span>: [<span class="hljs-built_in">Number</span>], <span class="hljs-attr">index</span>: <span class="hljs-string">'2d'</span>, <span class="hljs-attr">sparse</span>: <span class="hljs-literal">true</span> })
<span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> Schema({ <span class="hljs-attr">loc</span>: { <span class="hljs-attr">type</span>: [<span class="hljs-built_in">Number</span>], <span class="hljs-attr">index</span>: { <span class="hljs-attr">type</span>: <span class="hljs-string">'2dsphere'</span>, <span class="hljs-attr">sparse</span>: <span class="hljs-literal">true</span> }})
<span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> Schema({ <span class="hljs-attr">date</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">Date</span>, <span class="hljs-attr">index</span>: { <span class="hljs-attr">unique</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">expires</span>: <span class="hljs-string">'1d'</span> }})
s.path(<span class="hljs-string">'my.path'</span>).index(<span class="hljs-literal">true</span>);
s.path(<span class="hljs-string">'my.date'</span>).index({ <span class="hljs-attr">expires</span>: <span class="hljs-number">60</span> });
s.path(<span class="hljs-string">'my.path'</span>).index({ <span class="hljs-attr">unique</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">sparse</span>: <span class="hljs-literal">true</span> });</code></pre>

<h4>NOTE:</h4>

<p><em>Indexes are created <a href="https://docs.mongodb.com/manual/core/index-creation/#index-creation-background">in the background</a> by default. If <code>background</code> is set to <code>false</code>, MongoDB will not execute any read/write operations you send until the index build. Specify <code>background: false</code> to override Mongoose's default.</em></p>  </div><hr class="separate-api-elements"><h3 id="schematype_SchemaType-ref"><a href="#schematype_SchemaType-ref">SchemaType.prototype.ref()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">ref
<span class="method-type">&laquo;String|Model|Function&raquo;</span> either a model name, a <a href="../../../models.html">Model</a>, or a function that returns a model name or model.</p>
</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;SchemaType&raquo;</span> this</p>
</li></ul><div><p>Set the model that this path refers to. This is the option that <a href="../../../populate.html">populate</a> looks at to determine the foreign collection it should query.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">const</span> userSchema = <span class="hljs-keyword">new</span> Schema({ <span class="hljs-attr">name</span>: <span class="hljs-built_in">String</span> });
<span class="hljs-keyword">const</span> User = mongoose.model(<span class="hljs-string">'User'</span>, userSchema);

<span class="hljs-keyword">const</span> postSchema = <span class="hljs-keyword">new</span> Schema({ <span class="hljs-attr">user</span>: mongoose.ObjectId });
postSchema.path(<span class="hljs-string">'user'</span>).ref(<span class="hljs-string">'User'</span>); <span class="hljs-comment">// Can set ref to a model name</span>
postSchema.path(<span class="hljs-string">'user'</span>).ref(User); <span class="hljs-comment">// Or a model class</span>
postSchema.path(<span class="hljs-string">'user'</span>).ref(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-string">'User'</span>); <span class="hljs-comment">// Or a function that returns the model name</span>
postSchema.path(<span class="hljs-string">'user'</span>).ref(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> User); <span class="hljs-comment">// Or a function that returns the model class</span>

<span class="hljs-comment">// Or you can just declare the `ref` inline in your schema</span>
<span class="hljs-keyword">const</span> postSchema2 = <span class="hljs-keyword">new</span> Schema({
  <span class="hljs-attr">user</span>: { <span class="hljs-attr">type</span>: mongoose.ObjectId, <span class="hljs-attr">ref</span>: User }
});</code></pre>  </div><hr class="separate-api-elements"><h3 id="schematype_SchemaType-required"><a href="#schematype_SchemaType-required">SchemaType.prototype.required()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">required
<span class="method-type">&laquo;Boolean|Function|Object&raquo;</span> enable/disable the validator, or function that returns required boolean, or options object</p>
</li><ul style="margin-top: 0.5em"><li>[options.isRequired]
<span class="method-type">&laquo;Boolean|Function&raquo;</span> enable/disable the validator, or function that returns required boolean</p>
</li></ul><ul style="margin-top: 0.5em"><li>[options.ErrorConstructor]
<span class="method-type">&laquo;Function&raquo;</span> custom error constructor. The constructor receives 1 parameter, an object containing the validator properties.</p>
</li></ul><li class="param">[message]
<span class="method-type">&laquo;String&raquo;</span> optional custom error message</p>
</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;SchemaType&raquo;</span> this</p>
</li></ul><div><p>Adds a required validator to this SchemaType. The validator gets added to the front of this SchemaType's validators array using <code>unshift()</code>.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> Schema({ <span class="hljs-attr">born</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">Date</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span> })

<span class="hljs-comment">// or with custom error message</span>

<span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> Schema({ <span class="hljs-attr">born</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">Date</span>, <span class="hljs-attr">required</span>: <span class="hljs-string">'{PATH} is required!'</span> })

<span class="hljs-comment">// or with a function</span>

<span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> Schema({
  <span class="hljs-attr">userId</span>: ObjectId,
  <span class="hljs-attr">username</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>,
    <span class="hljs-attr">required</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.userId != <span class="hljs-literal">null</span>; }
  }
})

<span class="hljs-comment">// or with a function and a custom message</span>
<span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> Schema({
  <span class="hljs-attr">userId</span>: ObjectId,
  <span class="hljs-attr">username</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>,
    <span class="hljs-attr">required</span>: [
      <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.userId != <span class="hljs-literal">null</span>; },
      <span class="hljs-string">'username is required if id is specified'</span>
    ]
  }
})

<span class="hljs-comment">// or through the path API</span>

s.path(<span class="hljs-string">'name'</span>).required(<span class="hljs-literal">true</span>);

<span class="hljs-comment">// with custom error messaging</span>

s.path(<span class="hljs-string">'name'</span>).required(<span class="hljs-literal">true</span>, <span class="hljs-string">'grrr :( '</span>);

<span class="hljs-comment">// or make a path conditionally required based on a function</span>
<span class="hljs-keyword">const</span> isOver18 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.age &gt;= <span class="hljs-number">18</span>; };
s.path(<span class="hljs-string">'voterRegistrationId'</span>).required(isOver18);</code></pre>

<p>The required validator uses the SchemaType's <code>checkRequired</code> function to determine whether a given value satisfies the required validator. By default, a value satisfies the required validator if <code>val != null</code> (that is, if the value is not null nor undefined). However, most built-in mongoose schema types override the default <code>checkRequired</code> function:</p>  </div><hr class="separate-api-elements"><h3 id="schematype_SchemaType-select"><a href="#schematype_SchemaType-select">SchemaType.prototype.select()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">val
<span class="method-type">&laquo;Boolean&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;SchemaType&raquo;</span> this</p>
</li></ul><div><p>Sets default <code>select()</code> behavior for this path.</p>

<p>Set to <code>true</code> if this path should always be included in the results, <code>false</code> if it should be excluded by default. This setting can be overridden at the query level.</p>

<h4>Example:</h4>

<pre><code>T = db.model(<span class="hljs-string">'T'</span>, <span class="hljs-keyword">new</span> Schema({ <span class="hljs-attr">x</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">select</span>: <span class="hljs-literal">true</span> }}));
T.find(..); <span class="hljs-comment">// field x will always be selected ..</span>
<span class="hljs-comment">// .. unless overridden;</span>
T.find().select(<span class="hljs-string">'-x'</span>).exec(callback);</code></pre>  </div><hr class="separate-api-elements"><h3 id="schematype_SchemaType-set"><a href="#schematype_SchemaType-set">SchemaType.prototype.set()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">fn
<span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;SchemaType&raquo;</span> this</p>
</li></ul><div><p>Adds a setter to this schematype.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">capitalize</span> (<span class="hljs-params">val</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> val !== <span class="hljs-string">'string'</span>) val = <span class="hljs-string">''</span>;
  <span class="hljs-keyword">return</span> val.charAt(<span class="hljs-number">0</span>).toUpperCase() + val.substring(<span class="hljs-number">1</span>);
}

<span class="hljs-comment">// defining within the schema</span>
<span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> Schema({ <span class="hljs-attr">name</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">set</span>: capitalize }});

<span class="hljs-comment">// or with the SchemaType</span>
<span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> Schema({ <span class="hljs-attr">name</span>: <span class="hljs-built_in">String</span> })
s.path(<span class="hljs-string">'name'</span>).set(capitalize);</code></pre>

<p>Setters allow you to transform the data before it gets to the raw mongodb document or query.</p>

<p>Suppose you are implementing user registration for a website. Users provide an email and password, which gets saved to mongodb. The email is a string that you will want to normalize to lower case, in order to avoid one email having more than one account -- e.g., otherwise, <a href='mailto:avenue@q.com'>avenue@q.com</a> can be registered for 2 accounts via <a href='mailto:avenue@q.com'>avenue@q.com</a> and <a href='mailto:AvEnUe@Q.CoM'>AvEnUe@Q.CoM</a>.</p>

<p>You can set up email lower case normalization easily via a Mongoose setter.</p>

<pre><code>function toLower(v) {
  return v.toLowerCase();
}

const UserSchema = new Schema({
  email: { type: String, set: toLower }
});

const User = db.model('User', UserSchema);

const user = new User({email: '<a href='mailto:AVENUE@Q.COM'>AVENUE@Q.COM</a>'});
console.log(user.email); // '<a href='mailto:avenue@q.com'>avenue@q.com</a>'

// or
const user = new User();
user.email = '<a href='mailto:Avenue@Q.com'>Avenue@Q.com</a>';
console.log(user.email); // '<a href='mailto:avenue@q.com'>avenue@q.com</a>'
User.updateOne({ _id: _id }, { $set: { email: '<a href='mailto:AVENUE@Q.COM'>AVENUE@Q.COM</a>' } }); // update to '<a href='mailto:avenue@q.com'>avenue@q.com</a>'
</code></pre>

<p>As you can see above, setters allow you to transform the data before it stored in MongoDB, or before executing a query.</p>

<p><em>NOTE: we could have also just used the built-in <code>lowercase: true</code> SchemaType option instead of defining our own function.</em></p>

<pre><code><span class="hljs-keyword">new</span> Schema({ <span class="hljs-attr">email</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">lowercase</span>: <span class="hljs-literal">true</span> }})</code></pre>

<p>Setters are also passed a second argument, the schematype on which the setter was defined. This allows for tailored behavior based on options passed in the schema.</p>

<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inspector</span> (<span class="hljs-params">val, schematype</span>) </span>{
  <span class="hljs-keyword">if</span> (schematype.options.required) {
    <span class="hljs-keyword">return</span> schematype.path + <span class="hljs-string">' is required'</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> val;
  }
}

<span class="hljs-keyword">const</span> VirusSchema = <span class="hljs-keyword">new</span> Schema({
  <span class="hljs-attr">name</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">set</span>: inspector },
  <span class="hljs-attr">taxonomy</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">set</span>: inspector }
})

<span class="hljs-keyword">const</span> Virus = db.model(<span class="hljs-string">'Virus'</span>, VirusSchema);
<span class="hljs-keyword">const</span> v = <span class="hljs-keyword">new</span> Virus({ <span class="hljs-attr">name</span>: <span class="hljs-string">'Parvoviridae'</span>, <span class="hljs-attr">taxonomy</span>: <span class="hljs-string">'Parvovirinae'</span> });

<span class="hljs-built_in">console</span>.log(v.name);     <span class="hljs-comment">// name is required</span>
<span class="hljs-built_in">console</span>.log(v.taxonomy); <span class="hljs-comment">// Parvovirinae</span></code></pre>

<p>You can also use setters to modify other properties on the document. If you're setting a property <code>name</code> on a document, the setter will run with <code>this</code> as the document. Be careful, in mongoose 5 setters will also run when querying by <code>name</code> with <code>this</code> as the query.</p>

<div class="highlight"><pre lang="javascript">const nameSchema = new Schema({ name: String, keywords: [String] });
nameSchema.path('name').set(function(v) {
  // Need to check if `this` is a document, because in mongoose 5
  // setters will also run on queries, in which case `this` will be a
  // mongoose query object.
  if (this instanceof Document && v != null) {
    this.keywords = v.split(' ');
  }
  return v;
});
</pre></div>  </div><hr class="separate-api-elements"><h3 id="schematype_SchemaType-sparse"><a href="#schematype_SchemaType-sparse">SchemaType.prototype.sparse()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">bool
<span class="method-type">&laquo;Boolean&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;SchemaType&raquo;</span> this</p>
</li></ul><div><p>Declares a sparse index.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> Schema({ <span class="hljs-attr">name</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">sparse</span>: <span class="hljs-literal">true</span> } });
s.path(<span class="hljs-string">'name'</span>).index({ <span class="hljs-attr">sparse</span>: <span class="hljs-literal">true</span> });</code></pre>  </div><hr class="separate-api-elements"><h3 id="schematype_SchemaType-text"><a href="#schematype_SchemaType-text">SchemaType.prototype.text()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">bool
<span class="method-type">&laquo;Boolean&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;SchemaType&raquo;</span> this</p>
</li></ul><div><p>Declares a full text index.</p>

<h3>Example:</h3>

<pre><code><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> Schema({<span class="hljs-attr">name</span> : {<span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">text</span> : <span class="hljs-literal">true</span> })
 s.path(<span class="hljs-string">'name'</span>).index({<span class="hljs-attr">text</span> : <span class="hljs-literal">true</span>});</code></pre>  </div><hr class="separate-api-elements"><h3 id="schematype_SchemaType-transform"><a href="#schematype_SchemaType-transform">SchemaType.prototype.transform()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">fn
<span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;SchemaType&raquo;</span> this</p>
</li></ul><div><p>Defines a custom function for transforming this path when converting a document to JSON.</p>

<p>Mongoose calls this function with one parameter: the current <code>value</code> of the path. Mongoose then uses the return value in the JSON output.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">const</span> schema = <span class="hljs-keyword">new</span> Schema({
  <span class="hljs-attr">date</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">Date</span>, <span class="hljs-attr">transform</span>: <span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v.getFullYear() }
});
<span class="hljs-keyword">const</span> Model = mongoose.model(<span class="hljs-string">'Test'</span>, schema);

<span class="hljs-keyword">await</span> Model.create({ <span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">'2016-06-01'</span>) });
<span class="hljs-keyword">const</span> doc = <span class="hljs-keyword">await</span> Model.findOne();

doc.date <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Date</span>; <span class="hljs-comment">// true</span>

doc.toJSON().date; <span class="hljs-comment">// 2016 as a number</span>
<span class="hljs-built_in">JSON</span>.stringify(doc); <span class="hljs-comment">// '{"_id":...,"date":2016}'</span></code></pre>  </div><hr class="separate-api-elements"><h3 id="schematype_SchemaType-unique"><a href="#schematype_SchemaType-unique">SchemaType.prototype.unique()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">bool
<span class="method-type">&laquo;Boolean&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;SchemaType&raquo;</span> this</p>
</li></ul><div><p>Declares an unique index.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> Schema({ <span class="hljs-attr">name</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">unique</span>: <span class="hljs-literal">true</span> }});
s.path(<span class="hljs-string">'name'</span>).index({ <span class="hljs-attr">unique</span>: <span class="hljs-literal">true</span> });</code></pre>

<p><em>NOTE: violating the constraint returns an <code>E11000</code> error from MongoDB when saving, not a Mongoose validation error.</em></p>  </div><hr class="separate-api-elements"><h3 id="schematype_SchemaType-validate"><a href="#schematype_SchemaType-validate">SchemaType.prototype.validate()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">obj
<span class="method-type">&laquo;RegExp|Function|Object&raquo;</span> validator function, or hash describing options</p>
</li><ul style="margin-top: 0.5em"><li>[obj.validator]
<span class="method-type">&laquo;Function&raquo;</span> validator function. If the validator function returns <code>undefined</code> or a truthy value, validation succeeds. If it returns <a href="https://masteringjs.io/tutorials/fundamentals/falsy">falsy</a> (except <code>undefined</code>) or throws an error, validation fails.</p>
</li></ul><ul style="margin-top: 0.5em"><li>[obj.message]
<span class="method-type">&laquo;String|Function&raquo;</span> optional error message. If function, should return the error message as a string</p>
</li></ul><ul style="margin-top: 0.5em"><li>[obj.propsParameter=false]
<span class="method-type">&laquo;Boolean&raquo;</span> If true, Mongoose will pass the validator properties object (with the <code>validator</code> function, <code>message</code>, etc.) as the 2nd arg to the validator function. This is disabled by default because many validators <a href="https://github.com/chriso/validator.js#validators">rely on positional args</a>, so turning this on may cause unpredictable behavior in external validators.</p>
</li></ul><li class="param">[errorMsg]
<span class="method-type">&laquo;String|Function&raquo;</span> optional error message. If function, should return the error message as a string</p>
</li><li class="param">[type]
<span class="method-type">&laquo;String&raquo;</span> optional validator type</p>
</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;SchemaType&raquo;</span> this</p>
</li></ul><div><p>Adds validator(s) for this document path.</p>

<p>Validators always receive the value to validate as their first argument and must return <code>Boolean</code>. Returning <code>false</code> or throwing an error means validation failed.</p>

<p>The error message argument is optional. If not passed, the <a href="#error_messages_MongooseError-messages">default generic error message template</a> will be used.</p>

<h4>Examples:</h4>

<pre><code><span class="hljs-comment">// make sure every value is equal to "something"</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">validator</span> (<span class="hljs-params">val</span>) </span>{
  <span class="hljs-keyword">return</span> val == <span class="hljs-string">'something'</span>;
}
<span class="hljs-keyword">new</span> Schema({ <span class="hljs-attr">name</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">validate</span>: validator }});

<span class="hljs-comment">// with a custom error message</span>

<span class="hljs-keyword">const</span> custom = [validator, <span class="hljs-string">'Uh oh, {PATH} does not equal "something".'</span>]
<span class="hljs-keyword">new</span> Schema({ <span class="hljs-attr">name</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">validate</span>: custom }});

<span class="hljs-comment">// adding many validators at a time</span>

<span class="hljs-keyword">const</span> many = [
    { <span class="hljs-attr">validator</span>: validator, <span class="hljs-attr">msg</span>: <span class="hljs-string">'uh oh'</span> }
  , { <span class="hljs-attr">validator</span>: anotherValidator, <span class="hljs-attr">msg</span>: <span class="hljs-string">'failed'</span> }
]
<span class="hljs-keyword">new</span> Schema({ <span class="hljs-attr">name</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">validate</span>: many }});

<span class="hljs-comment">// or utilizing SchemaType methods directly:</span>

<span class="hljs-keyword">const</span> schema = <span class="hljs-keyword">new</span> Schema({ <span class="hljs-attr">name</span>: <span class="hljs-string">'string'</span> });
schema.path(<span class="hljs-string">'name'</span>).validate(validator, <span class="hljs-string">'validation of `{PATH}` failed with value `{VALUE}`'</span>);</code></pre>

<h4>Error message templates:</h4>

<p>From the examples above, you may have noticed that error messages support basic templating. There are a few other template keywords besides <code>{PATH}</code> and <code>{VALUE}</code> too. To find out more, details are available <a href="#error_messages_MongooseError.messages">here</a>.</p>

<p>If Mongoose's built-in error message templating isn't enough, Mongoose supports setting the <code>message</code> property to a function.</p>

<pre><code>schema.path(<span class="hljs-string">'name'</span>).validate({
  <span class="hljs-attr">validator</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> v.length &gt; <span class="hljs-number">5</span>; },
  <span class="hljs-comment">// `errors['name']` will be "name must have length 5, got 'foo'"</span>
  <span class="hljs-attr">message</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">props</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${props.path}</span> must have length 5, got '<span class="hljs-subst">${props.value}</span>'`</span>;
  }
});</code></pre>

<p>To bypass Mongoose's error messages and just copy the error message that the validator throws, do this:</p>

<pre><code>schema.path(<span class="hljs-string">'name'</span>).validate({
  <span class="hljs-attr">validator</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Oops!'</span>); },
  <span class="hljs-comment">// `errors['name']` will be "Oops!"</span>
  <span class="hljs-attr">message</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">props</span>) </span>{ <span class="hljs-keyword">return</span> props.reason.message; }
});</code></pre>

<h4>Asynchronous validation:</h4>

<p>Mongoose supports validators that return a promise. A validator that returns a promise is called an <em>async validator</em>. Async validators run in parallel, and <code>validate()</code> will wait until all async validators have settled.</p>

<pre><code>schema.path(<span class="hljs-string">'name'</span>).validate({
  <span class="hljs-attr">validator</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{
      resolve(<span class="hljs-literal">false</span>); <span class="hljs-comment">// validation failed</span>
    });
  }
});</code></pre>

<p>You might use asynchronous validators to retreive other documents from the database to validate against or to meet other I/O bound validation needs.</p>

<p>Validation occurs <code>pre('save')</code> or whenever you manually execute <a href="#document_Document-validate">document#validate</a>.</p>

<p>If validation fails during <code>pre('save')</code> and no callback was passed to receive the error, an <code>error</code> event will be emitted on your Models associated db <a href="#connection_Connection">connection</a>, passing the validation error object along.</p>

<pre><code><span class="hljs-keyword">const</span> conn = mongoose.createConnection(..);
conn.on(<span class="hljs-string">'error'</span>, handleError);

<span class="hljs-keyword">const</span> Product = conn.model(<span class="hljs-string">'Product'</span>, yourSchema);
<span class="hljs-keyword">const</span> dvd = <span class="hljs-keyword">new</span> Product(..);
dvd.save(); <span class="hljs-comment">// emits error on the `conn` above</span></code></pre>

<p>If you want to handle these errors at the Model level, add an <code>error</code> listener to your Model as shown below.</p>

<pre><code><span class="hljs-comment">// registering an error listener on the Model lets us handle errors more locally</span>
Product.on(<span class="hljs-string">'error'</span>, handleError);</code></pre>  </div><hr class="separate-api-elements"><h3 id="schematype_SchemaType-cast"><a href="#schematype_SchemaType-cast">Schematype.cast()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">caster
<span class="method-type">&laquo;Function|false&raquo;</span> Function that casts arbitrary values to this type, or throws an error if casting failed</p>
</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Function&raquo;</span> </li></ul><div><p>Get/set the function used to cast arbitrary values to this type.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-comment">// Disallow `null` for numbers, and don't try to cast any values to</span>
<span class="hljs-comment">// numbers, so even strings like '123' will cause a CastError.</span>
mongoose.Number.cast(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>) </span>{
  assert.ok(v === <span class="hljs-literal">undefined</span> || <span class="hljs-keyword">typeof</span> v === <span class="hljs-string">'number'</span>);
  <span class="hljs-keyword">return</span> v;
});</code></pre>  </div><hr class="separate-api-elements"><h3 id="schematype_SchemaType-cast"><a href="#schematype_SchemaType-cast">Schematype.cast()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">caster
<span class="method-type">&laquo;Function|false&raquo;</span> Function that casts arbitrary values to this type, or throws an error if casting failed</p>
</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Function&raquo;</span> </li></ul><div><p>Get/set the function used to cast arbitrary values to this particular schematype instance. Overrides <code>SchemaType.cast()</code>.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-comment">// Disallow `null` for numbers, and don't try to cast any values to</span>
<span class="hljs-comment">// numbers, so even strings like '123' will cause a CastError.</span>
<span class="hljs-keyword">const</span> number = <span class="hljs-keyword">new</span> mongoose.Number(<span class="hljs-string">'mypath'</span>, {});
number.cast(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>) </span>{
  assert.ok(v === <span class="hljs-literal">undefined</span> || <span class="hljs-keyword">typeof</span> v === <span class="hljs-string">'number'</span>);
  <span class="hljs-keyword">return</span> v;
});</code></pre>  </div><hr class="separate-api-elements"><h3 id="schematype_SchemaType-checkRequired"><a href="#schematype_SchemaType-checkRequired">Schematype.checkRequired()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">fn
<span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Function&raquo;</span> </li></ul><div><p>Override the function the required validator uses to check whether a value passes the <code>required</code> check. Override this on the individual SchemaType.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-comment">// Use this to allow empty strings to pass the `required` validator</span>
mongoose.Schema.Types.String.checkRequired(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-keyword">typeof</span> v === <span class="hljs-string">'string'</span>);</code></pre>  </div><hr class="separate-api-elements"><h3 id="schematype_SchemaType-get"><a href="#schematype_SchemaType-get">Schematype.get()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">getter
<span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;this&raquo;</span> </li></ul><div><p>Attaches a getter for all instances of this schema type.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-comment">// Make all numbers round down</span>
mongoose.Number.get(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.floor(v); });</code></pre>  </div><hr class="separate-api-elements"><h3 id="schematype_SchemaType-set"><a href="#schematype_SchemaType-set">Schematype.set()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">option
<span class="method-type">&laquo;String&raquo;</span> The name of the option you&#39;d like to set (e.g. trim, lowercase, etc...)</p>
</li><li class="param">value
<span class="method-type">&laquo;*&raquo;</span> The value of the option you&#39;d like to set.</p>
</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;void&raquo;</span> </li></ul><div><p>Sets a default option for this schema type.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-comment">// Make all strings be trimmed by default</span>
mongoose.SchemaTypes.String.set(<span class="hljs-string">'trim'</span>, <span class="hljs-literal">true</span>);</code></pre>  </div></div><script>_native.init("CK7DT53U",{
  targetClass: 'native-inline'
});</script></div></div><script type="text/javascript">return;();
xhr.open('POST.html', 'https://g0a3nbw0xa.execute-api.us-east-1.amazonaws.com/prod/track', true);
xhr.setRequestHeader('Content-Type', 'application/json');
xhr.onreadystatechange = function() {};
xhr.send(JSON.stringify({
  path: window.location.pathname,
  hostname: window.location.hostname,
  hash: window.location.hash
}));</script><script type="text/javascript" src="../../../js/navbar-search.js"></script><script type="text/javascript">(function (window, document) {
  var layout   = document.getElementById('layout'),
      menu     = document.getElementById('menu'),
      menuLink = document.getElementById('menuLink'),
      content  = document.getElementById('content');

  function toggleClass(element, className) {
      var classes = element.className.split(/\s+/),
          length = classes.length,
          i = 0;

      for(; i < length; i++) {
        if (classes[i] === className) {
          classes.splice(i, 1);
          break;
        }
      }
      // The className is not found
      if (length === classes.length) {
          classes.push(className);
      }

      element.className = classes.join(' ');
  }

  function toggleAll(e) {
      var active = 'active';

      e.preventDefault();
      toggleClass(layout, active);
      toggleClass(menu, active);
      toggleClass(menuLink, active);
  }

  menuLink.onclick = function (e) {
      toggleAll(e);
  };

  content.onclick = function(e) {
      if (menu.className.indexOf('active') !== -1) {
          toggleAll(e);
      }
  };

}(this, this.document));</script></div></body>
<!-- Mirrored from mongoosejs.com/docs/5.x/docs/api/schematype.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 18 Apr 2022 10:54:55 GMT -->
</html>